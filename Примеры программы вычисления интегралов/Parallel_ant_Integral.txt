Scheme Test
{
	//(a, b, Eps, p)
	@ = Integrate(Func);

	
	//f(x) = sin(0,5*x^3)*sin(0.25*x^2)*sin(0.125*x)
	Func = (	(((([1]*[1]).mul*[1]).mul * 0.5).mul.sin * 
					(([1]*[1]).mul * 0.25).mul.sin).mul * 
					([1] * 0.125).mul.sin
				).mul;
				
	//f(x) = 1/(x*e^x) 
	Func2 = (1 * ([1] * [1].exp).mul).div;
	
	//f(x) = x*x*2+x+x^(1/2)
	Func3 = ((((([1]*[1]).mul * 2).mul) * [1]).add * [1].sqrt).add;

	Func4 = [1].sin;
				
	//Интегрирование методом трапеции.
	//Параметры A*B*Eps*p - границы отрезка интегрирования, точность, степень параллелизма.
	Fun Integrate[fFunction]
	{		
		//Start_Integr(a, b, Eps)
		@ = ([3] * [1] * [2] * ([2] * [1]).sub).	//(Eps, a, b, b-a)
			(	[1] * [2] * [3] * ([4] * 2).div * ([4] * 4).div		
			).Integr; 								//Integr(Eps, a, b, (b-a)/2, Trp(a, b, a-b))
			
		
		//Integr(Eps, a, b, h, h/2)
		Integr = 	(	(([2] * [3] * [5]).Trp * ([2] * [3] * [4]).Trp * [1]	//|Trp(h) - Trp(h/2)|/3
						).(Rungreater -> true, false * [1].print.("\n".print)) ->					//if (runge > Eps)	
						(	[1] * [2] * [3] * 
							([5] * 2).div * ([5] * 4).div
						).Integr						//then Integr(Eps, a, b, h/4, h/8)
					);
		
		Rungreater = (Runge * [3]).greater;
		
		//Runge(Trp(h), Trp(h/2)
		Runge = (([1] * [2]).sub.abs * 3).div;

		
		//Trp[f(x)](a,b,h) = h*((f(a)+f(b))/2+Sum(a+h,b-h,h))
		Trp = 	(	[3] * 
					(
						(
							(	[1].fFunction * 
								[2].fFunction
							).add * 
							2
						).div * 
						(	([1] * [3]).add * 
							([2] * [3]).sub * 
							[3]
						).Sum
					).add
				).mul;

				
		//Sum[f(x)](a,b,h) = if (a==b) f(a) elseif (a>b) 0 else f(a) + f(b) + Sum(a+h,b-h,h)
		Sum = ([1] * [2]).equal -> 
				[1].fFunction, 
				([1] * [2]).greater -> 
					0,
					([1].fFunction * 
						([2].fFunction *
							(	([1] * [3]).add * 
								([2] * [3]).sub * 
								[3]
							).Sum
						).add
					).add;
	}

}

Application
%Test(0.0 * 25.0 * 0.0000000001)