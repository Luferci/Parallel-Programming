Scheme Test
{
	//(a, b, Eps, p)
	@ = Integrate(Func).print;

	
	//f(x) = sin(0,5*x^3)*sin(0.25*x^2)*sin(0.125*x)
	Func = (	(((([1]*[1]).mul*[1]).mul * 0.5).mul.sin * 
					(([1]*[1]).mul * 0.25).mul.sin).mul * 
					([1] * 0.125).mul.sin
				).mul;

				
	//Интегрирование методом трапеции.
	//Параметры A*B*Eps*p - границы отрезка интегрирования, точность, степень параллелизма.
	Fun Integrate[fFunction]
	{
		@ = ([1] * [2] * ([3] * [4]).div * (([2] * [1]).sub * [4]).div).Paral;
	
		//Paral(a, b, Eps/p, h)
		Paral = (id * ([1] * [4]).add						//(a, b, Eps/p, h, a+h)
			).(	([2] * [1]).greater -> 						//b > a ?
					(	([1] * [5] * [3]).Start_Integr *	//Да: Start_Integr(a, a+h, Eps/p) +
						([5] * [2] * [3] * [4]).Paral		//+ Paral(a+h, b, Eps/p, h)
					).add,
					0										//Нет: 0.
			);
		
		//Start_Integr(a, b, Eps)
		Start_Integr = ([3] * [1] * [2] * ([2] * [1]).sub).	//(Eps, a, b, b-a)
			(	[1] * [2] * [3] * ([4] * 2).div * 		
				([1] * [2] * [4]).Trp					
			).Integr; 								//Integr(Eps, a, b, (b-a)/2, Trp(a, b, a-b))
			
		
		//Integr(Eps, a, b, h/2, Trp(h))
		Integr = 	(	id *							//Пробрасываем входной кортеж дальше	
						([2] * [3] * [4]).Trp			//Trp(a, b, h/2)
					).									//(Eps, a, b, h/2, Trp(h), Trp(h/2))
//Оптимизация: сформировали новый кортеж из входного и Trp(a, b, h/2),
//чтобы в дальнейшем не пересчитавать Trp(a, b, h/2) несколько раз.
					(	([5] * [6]).Runge *				//|Trp(h) - Trp(h/2)|/3
						id								//(runge, Eps, a, b, h/2, Trp(h), Trp(h/2))
					).( 
//Условная композиция взята в скобки, 
//чтобы не только условие имело доступ к предыдущему кортежу,
//но и ветки then и else.
						greater ->						//if (runge > Eps)	
						(	[2] * [3] * [4] * 
							([5] * 2).div * [7]
						).Integr,						//then Integr(Eps, a, b, h/4, I(h/2))
						[7]								//else Trp(h/2)
					);

					
		//По правилу Рунге для метода трапеции |Trp(h) - Trp(h/2)|/3 <= Eps
		//Runge(Trp(h), Trp(h/2)
		Runge = (([1] * [2]).sub.abs * 3).div;

		
		//Trp[f(x)](a,b,h) = h*((f(a)+f(b))/2+Sum(a+h,b-h,h))
		Trp = 	(	[3] * 
					(
						(
							(	[1].fFunction * 
								[2].fFunction
							).add * 
							2
						).div * 
						(	([1] * [3]).add * 
							([2] * [3]).sub * 
							[3]
						).Sum
					).add
				).mul;

				
		//Sum[f(x)](a,b,h) = if (a==b) f(a) elseif (a>b) 0 else f(a) + f(b) + Sum(a+h,b-h,h)
		Sum = ([1] * [2]).equal -> 
				[1].fFunction, 
				([1] * [2]).greater -> 
					0,
					([1].fFunction * 
						([2].fFunction *
							(	([1] * [3]).add * 
								([2] * [3]).sub * 
								[3]
							).Sum
						).add
					).add;
	}

}

Application
%Test(0.0 * 25.0 * 0.000000001 * 8)