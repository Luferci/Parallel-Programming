Scheme Test
{

	@ = Integrate(TestFunc).print;

	//f(x) = sin(0,5*x^3)*sin(0.25*x^2)*sin(0.125*x)
	TestFunc = (((((id*id).mul*id).mul * 0.5).mul.sin * ((id*id).mul * 0.25).mul.sin).mul * (id * 0.125).mul.sin).mul;

	
	// ѕараметры A*B*Eps - границы отрезка интегрировани€ и точность.
	Fun Integrate[fFunction]
	{
		@ = (	(	(	([1] * Mid).Trp * 		//¬ычисл€ем дл€ шага h/2
						(Mid * [2]).Trp			//Integrate(a, b) = Trp(a, (a+b)/2) + Trp((a+b)/2, b)
					).add * 					//
					([1] * [2]).Trp				//¬ычисл€ем дл€ шага h (параллельно c h/2)
				).sub.abs * 					//|Trp(h/2) - Trp(h)|
				[3]								//
			).less ->							//|Trp(h/2) - Trp(h)| < Eps?
				([1] * [2]).Trp,				//ƒа - возвращаем Trp(h)
//ќшибки: Trp(h) расчитываетс€ второй раз, нужно возвращать Trp(h/2).
				(	(	[1] * 					//Ќет - возвращаем 
						Mid * 					//Integrate(a, (a+b)/2, Eps/2) +
						([3] * 2.0).div			//+ Integrate((a+b)/2, b, Eps/2)
					).@ * 						//
					(	Mid * 					//Integrate здесь вычисл€ютс€ параллельно.
						[2] * 					// ак следствие - неконтролируема€ зернистость.
						([3] * 2.0).div			//
					).@							//
				).add;							//
//ќшибка: в Integrate(a, (a+b)/2, Eps/2) будет повторно расчитываетс€ Trp(a, (a+b)/2),
//а в Integrate((a+b)/2, b, Eps/2) будет повторно расчитываетс€ Trp((a+b)/2, b).

//Ќеконтролируемый рост зернистости в совкупности с повторными пересчЄтами
//замедл€ет вычислени€ на пор€дки по сравнению с 
//последовательным алгоритмом без повторных пересчЄтов.
//(Ќа входных данных (0.0 * 25.0 * 0.0000001) примерно 60 секунд против 0,4,
//несмотр€ на использование в первом случае 8 вычислительных €дер.)


		Mid = (([1] * [2]).add * 2.0).div;

		
		//ћетод трапеции
		//Trp[f(x)](a, b) = (b-a)*(f(a)+f(b))/2
		Trp = ((([2] * [1]).sub * ([2].fFunction * [1].fFunction).add).mul * 2.0).div;
	}

}

Application
%Test(0.0 * 10.0 * 0.0000001)