Scheme Test
{

	@ = Integrate(TestFunc).print;

	//f(x) = sin(0,5*x^3)*sin(0.25*x^2)*sin(0.125*x)
	TestFunc = (((((id*id).mul*id).mul * 0.5).mul.sin * ((id*id).mul * 0.25).mul.sin).mul * (id * 0.125).mul.sin).mul;

	
	// Параметры A*B*Eps - границы отрезка интегрирования и точность.
	Fun Integrate[fFunction]
	{
		@ = (	(	(	([1] * Mid).Trp * 		//Вычисляем для шага h/2
						(Mid * [2]).Trp			//Integrate(a, b) = Trp(a, (a+b)/2) + Trp((a+b)/2, b)
					).add * 					//
					([1] * [2]).Trp				//Вычисляем для шага h (параллельно c h/2)
				).sub.abs * 					//|Trp(h/2) - Trp(h)|
				[3]								//
			).less ->							//|Trp(h/2) - Trp(h)| < Eps?
				([1] * [2]).Trp,				//Да - возвращаем Trp(h)
//Ошибки: Trp(h) расчитывается второй раз, нужно возвращать Trp(h/2).
				(	(	[1] * 					//Нет - возвращаем 
						Mid * 					//Integrate(a, (a+b)/2, Eps/2) +
						([3] * 2.0).div			//+ Integrate((a+b)/2, b, Eps/2)
					).@ * 						//
					(	Mid * 					//Integrate здесь вычисляются параллельно.
						[2] * 					//Как следствие - неконтролируемая зернистость.
						([3] * 2.0).div			//
					).@							//
				).add;							//
//Ошибка: в Integrate(a, (a+b)/2, Eps/2) будет повторно расчитывается Trp(a, (a+b)/2),
//а в Integrate((a+b)/2, b, Eps/2) будет повторно расчитывается Trp((a+b)/2, b).

//Неконтролируемый рост зернистости в совкупности с повторными пересчётами
//замедляет вычисления на порядки по сравнению с 
//последовательным алгоритмом без повторных пересчётов.
//(На входных данных (0.0 * 25.0 * 0.0000001) примерно 60 секунд против 0,4,
//несмотря на использование в первом случае 8 вычислительных ядер.)


		Mid = (([1] * [2]).add * 2.0).div;

		
		//Метод трапеции
		//Trp[f(x)](a, b) = (b-a)*(f(a)+f(b))/2
		Trp = ((([2] * [1]).sub * ([2].fFunction * [1].fFunction).add).mul * 2.0).div;
	}

}

Application
%Test(0.0 * 10.0 * 0.0000001)