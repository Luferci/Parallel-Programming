Scheme Test
{

	@ = Integrate(Func).print;

	
	//f(x) = sin(0,5*x^3)*sin(0.25*x^2)*sin(0.125*x)
	Func = (	(((([1]*[1]).mul*[1]).mul * 0.5).mul.sin * 
					(([1]*[1]).mul * 0.25).mul.sin).mul * 
					([1] * 0.125).mul.sin
				).mul;

				
	//Интегрирование методом трапеции. Последовательный вариант.
	//Параметры A*B*Eps - границы отрезка интегрирования и точность.
	Fun Integrate[fFunction]
	{
		@ = ([3] * [1] * [2] * ([2] * [1]).sub).	//(Eps, a, b, b-a)
			(	[1] * [2] * [3] * ([4] * 2).div * 		
				([1] * [2] * [4]).Trp					
			).Integr; 								//Integr(Eps, a, b, (b-a)/2, Trp(a, b, a-b))
			
		
		//Integr(Eps, a, b, h/2, Trp(h))
		Integr = 	(	id *							//Пробрасываем входной кортеж дальше	
						([2] * [3] * [4]).Trp			//Trp(a, b, h/2)
					).									//(Eps, a, b, h/2, Trp(h), Trp(h/2))
//Оптимизация: сформировали новый кортеж из входного и Trp(a, b, h/2),
//чтобы в дальнейшем не пересчитавать Trp(a, b, h/2) несколько раз.
					(	([5] * [6]).Runge *				//|Trp(h) - Trp(h/2)|/3
						id								//(runge, Eps, a, b, h/2, Trp(h), Trp(h/2))
					).(	
//Условная композиция взята в скобки, 
//чтобы не только условие имело доступ к предыдущему кортежу,
//но и ветки then и else.
						greater ->						//if (runge > Eps)	
						(	[2] * [3] * [4] * 
							([5] * 2).div * [7]
						).Integr,						//then Integr(Eps, a, b, h/4, I(h/2))
						[7]								//else Trp(h/2)
					);

					
		//По правилу Рунге для метода трапеции |Trp(h) - Trp(h/2)|/3 <= Eps
		//Runge(Trp(h), Trp(h/2)
		Runge = (([1] * [2]).sub.abs * 3).div;

		
		//Trp[f(x)](a,b,h) = h*((f(a)+f(b))/2+Sum(a+h,b-h,h))
		Trp = 	(	[3] * 
					(
						(
							(	[1].fFunction * 
								[2].fFunction
							).add * 
							2
						).div * 
						(	([1] * [3]).add * 
							([2] * [3]).sub * 
							[3]
						).Sum
					).add
				).mul;

				
		//Sum[f(x)](a,b,h) = if (a==b) f(a) elseif (a>b) 0 else f(a) + f(b) + Sum(a+h,b-h,h)
		Sum = ([1] * [2]).equal -> 
				[1].fFunction, 
				([1] * [2]).greater -> 
					0,
					([1].fFunction * 
						([2].fFunction *
							(	([1] * [3]).add * 
								([2] * [3]).sub * 
								[3]
							).Sum
						).add
					).add;
	}

}

Application
%Test(0.0 * 10.0 * 0.0000001)