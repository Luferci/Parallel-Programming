Scheme Test
{

	@ = Integrate(Func).print;

	//f(x) = sin(0,5*x^3)*sin(0.25*x^2)*sin(0.125*x)
	Func = (	(	((([1]*[1]).mul*[1]).mul * 0.5).mul.sin * 
					(([1]*[1]).mul * 0.25).mul.sin
				).mul * 
					([1] * 0.125).mul.sin
				).mul;

	
	// Параметры A*B*Eps - границы отрезка интегрирования и точность.
	Fun Integrate[fFunction]
	{
		@ = ([3] * [1] * [2] * ([1] * [2]).Trp).Integr;
		
		//Integr(Eps, a, b, Trp(h))
		Integr = (	id * 
					([2] * [3]).Mid				///(Eps, a, b, Trp(h), Mid)
				).(	id*
					([2] * [5]).Trp * 		
					([5] * [3]).Trp				//(Eps, a, b, Trp(h), Mid, Trp(am), Trp(mb))
				).(	id * 
					([6] * [7]).add				//(Eps, a, b, Trp(h), Mid, Trp(am), Trp(mb), Trp(h/2))
				).(	([4]*[8]).sub.abs * 
					id * 
					([1] * 2).div		
//(|Trp(h/2) - Trp(h)|, Eps, a, b, Trp(h), Mid, Trp(am), Trp(mb), Trp(h/2), Eps/2)
				).(less ->						//|Trp(h/2) - Trp(h)| < Eps?
					[9],							
					(	(	[10] *					//Нет - возвращаем 
							[3] * 					//Integr(Eps/2, a, (a+b)/2, Trp(am)) +
							[6] *  					//+ Integr(Eps/2, (a+b)/2, b, Trp(mb))
							[7]
						).Integr * 					//здесь нельзя использовать @, т.к. в этом случае будет вызвана функция Integrate
						(	[10] *					//Integr здесь вычисляются параллельно.
							[6] * 					//Как следствие - неконтролируемый рост зернистости.
							[4] *
							[8]
						).Integr							//
					).add);

//(|Trp(h/2) - Trp(h)|, Eps, a, b, Mid, Trp(h), Trp(am), Trp(mb), Trp(h/2), Eps/2)
//2.95639e-54 * 5  * 5e-08 * 0 * 2.5e-08 * -6.10352e-54 * -3.09944e-54 * -4.76837e-56 * -3.14713e-54 * 2.5 *
//0.760003    * 10 * 5e-08 * 5 * 2.5     * 0.0158117    * 0.383954     * 0.39186      * 0.775815     * 5

//Неконтролируемый рост зернистости 
//замедляет вычисления на порядки по сравнению с 
//последовательным алгоритмом.
//(На входных данных (0.0 * 25.0 * 0.0000001) примерно 60 секунд против 0,4,
//несмотря на использование в первом случае 8 вычислительных ядер.)
		
		//Mean = (add * 2).div;
		
		//Min = less -> [1], [2];

		Mid = (([1] * [2]).add * 2.0).div;

		
		//Метод трапеции
		//Trp[f(x)](a, b) = (b-a)*(f(a)+f(b))/2
		Trp = ((([2] * [1]).sub.abs * ([2].fFunction * [1].fFunction).add).mul * 2.0).div;
	}

}

Application
%Test(0.0 * 25.0 * 0.000001)